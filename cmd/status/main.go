// Copyright 2018-2019 opcua authors. All rights reserved.
// Use of this source code is governed by a MIT-style license that can be
// found in the LICENSE file.

package main

import (
	"bufio"
	"bytes"
	"flag"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"strings"
	"text/template"
)

func main() {
	log.SetFlags(0)

	in := flag.String("in", "schema/StatusCode.csv", "path to StatusCodes.csv")
	out := flag.String("out", "status/status.go", "path to generated file")
	flag.Parse()

	if *in == "" {
		log.Fatal("-in is required")
	}
	if *out == "" {
		log.Fatal("-out is required")
	}

	f, err := os.Open(*in)
	if err != nil {
		log.Fatalf("Error reading %s: %v", *in, err)
	}
	defer f.Close()

	// rows have the format of "name,id,description"
	// but the description is not quoted and can contain commas
	// Therefore, do not use the csv.Reader here.

	var rows [][]string
	sc := bufio.NewScanner(f)
	for sc.Scan() {
		rows = append(rows, strings.SplitN(sc.Text(), ",", 3))
	}
	if sc.Err() != nil {
		log.Fatalf("Error parsing csv: %v", err)
	}

	var b bytes.Buffer
	if err := tmpl.Execute(&b, rows); err != nil {
		log.Fatalf("Error generating code: %v", err)
	}

	bfmt, err := format.Source(b.Bytes())
	if err != nil {
		log.Fatalf("Error formatting source: %v", err)
	}

	if err := ioutil.WriteFile(*out, bfmt, 0644); err != nil {
		log.Fatalf("Error writing %s: %v", *out, err)
	}
	log.Printf("Wrote status codes to %s", *out)
}

var tmpl = template.Must(template.New("").Parse(`
// Copyright 2018-2019 opcua authors. All rights reserved.
// Use of this source code is governed by a MIT-style license that can be
// found in the LICENSE file.

// Code generated by cmd/status. DO NOT EDIT!

package status

const (
	{{range .}}{{index . 0}} = {{index . 1}}
	{{end}}
)
`))
