package main

import (
	"bytes"
	"flag"
	"go/format"
	"io/ioutil"
	"log"
	"path/filepath"
	"strings"
	"text/template"
)

func main() {
	log.SetFlags(0)

	var in, out, pkg string
	flag.StringVar(&in, "in", "schema/Opc.Ua.Types.bsd", "Path to Opc.Ua.Types.bsd file")
	flag.StringVar(&out, "out", "ua", "Path to output directory")
	flag.StringVar(&pkg, "pkg", "ua", "Go package name")
	flag.Parse()

	dict, err := ReadTypes(in)
	if err != nil {
		log.Fatalf("Failed to read type definitions: %s", err)
	}

	var b bytes.Buffer
	if err := tmplHeader.Execute(&b, pkg); err != nil {
		log.Fatalf("Failed to generate header: %s", err)
	}

	for _, e := range Enums(dict) {
		if err := e.Source(&b); err != nil {
			log.Fatalf("Failed to format code for enum %s: %v", e.Name, err)
		}
	}

	src, err := format.Source(b.Bytes())
	if err != nil {
		log.Fatalf("Failed to format source: %v", err)
	}

	path := filepath.Join(out, "enums_gen.go")
	if err := ioutil.WriteFile(path, src, 0644); err != nil {
		log.Fatalf("Failed to write %s: %v", path, err)
	}
	log.Printf("Wrote enums to %s", path)

}

// func snakeCase(s string) string {
// 	var x []rune

// 	for i, r := range s {
// 		if r >= 'A' && r <= 'Z' {
// 			if i > 0 {
// 				x = append(x, '_')
// 			}
// 			x = append(x, unicode.ToLower(r))
// 		} else {
// 			x = append(x, r)
// 		}
// 	}

// 	s = string(x)
// 	// quick fix for "ID" -> "i_d" until the function is fixed
// 	s = strings.Replace(s, "i_d", "id", -1)
// 	return s
// }

func Enums(dict *TypeDictionary) []*Enum {
	var enums []*Enum

	r := strings.NewReplacer("Id", "ID", "IDentity", "Identity", "Guid", "GUID", "Json", "JSON", "Uadp", "UADP", "QualityOfService", "QoS")
	for _, v := range dict.Enums {
		t := &Enum{
			Name: r.Replace(v.Name),
		}

		switch {
		case v.Bits <= 8:
			t.Type = "uint8"
		case v.Bits <= 16:
			t.Type = "uint16"
		case v.Bits <= 32:
			t.Type = "uint32"
		default:
			t.Type = "uint64"
		}

		for _, val := range v.Values {
			ev := &EnumValue{
				Name:  r.Replace(t.Name + val.Name),
				Value: val.Value,
			}
			t.Values = append(t.Values, ev)
		}
		enums = append(enums, t)
	}
	return enums
}

var tmplHeader = template.Must(template.New("").Parse(`
// Copyright 2018-2019 opcua authors. All rights reserved.
// Use of this source code is governed by a MIT-style license that can be
// found in the LICENSE file.

// Code generated by cmd/service. DO NOT EDIT!

package {{.}}
`))
